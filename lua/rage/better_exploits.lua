-- @note: main cheat config region
local g_cheat_cfg = { }
g_cheat_cfg.m_current_exploit = ui.get_combo_box( 'rage_active_exploit' )
g_cheat_cfg.m_exploit_bind = ui.get_key_bind( 'rage_active_exploit_bind' )

-- @note: menu class region
local g_menu = { }

ui.add_slider_int( '                  [ rage ]', 'tc_label1', 0, 0, 0 )

g_menu.m_better_exploits = ui.add_check_box( 'better exploits', 'tc_better_exploits', false )
g_menu.m_hide_shots = ui.add_key_bind( 'hide shots', 'tc_hide_shots', 0, 1 )
g_menu.m_double_tap = ui.add_key_bind( 'doubletap', 'tc_doubletap', 0, 1 )
g_menu.m_double_tap_additives = ui.add_multi_combo_box( 'additives', 'tc_additives', { 'instant mode', 'extended teleport' }, { false, false } )

-- @note: exploit base region
local g_exploits = { }
g_exploits.m_cheat_fire = false
g_exploits.m_cheat_fire_time = 0
g_exploits.m_cheat_fire_diff = 0
g_exploits.m_should_recharge = false
g_exploits.m_is_saved_tick_count = false
g_exploits.m_recharge_tick_count = 0
g_exploits.m_diff = 0

-- @note: functional region
local g_functional = { }

g_functional.better_exploits = function( )
    -- @note: we shouldn`t use this function
    if not g_menu.m_better_exploits:get_value( ) then
        return end

    -- @note: when custom bind is active
    if g_menu.m_hide_shots:is_active( ) or g_menu.m_double_tap:is_active( ) then
        g_cheat_cfg.m_exploit_bind:set_type( 0 )

        if g_menu.m_double_tap:is_active( ) then
            if g_exploits.m_should_recharge and g_menu.m_double_tap_additives:get_value( 0 ) and g_menu.m_double_tap_additives:get_value( 1 ) then
                g_cheat_cfg.m_current_exploit:set_value( 0 )
            else
                g_cheat_cfg.m_current_exploit:set_value( 2 )
            end
        else
            if g_menu.m_hide_shots:is_active( ) then
                g_cheat_cfg.m_current_exploit:set_value( 1 )
            end
        end
    else
        g_cheat_cfg.m_exploit_bind:set_type( 1 )
        g_cheat_cfg.m_exploit_bind:set_key( 0 )
        g_cheat_cfg.m_current_exploit:set_value( 0 )
    end
end

local g_local_player = nil

-- @note: createmove region
local function on_create_move( cmd )
    -- @note: local player register
    g_local_player = entitylist.get_local_player( )
    -- @note: process recharge when fire
    if g_exploits.m_cheat_fire then
        -- @note: setup fire diff
        g_exploits.m_cheat_fire_diff = globalvars.get_current_time( ) - g_exploits.m_cheat_fire_time
        -- @note: when difference is big enough
        if g_exploits.m_cheat_fire_diff > 2.5 / 10 then
            g_exploits.m_should_recharge = true
            g_exploits.m_cheat_fire = false
        end
    end
    -- @note: tick count is not saved while recharge
    if g_exploits.m_should_recharge and not g_exploits.m_is_saved_tick_count then
        g_exploits.m_recharge_tick_count = cmd.tick_count

        g_exploits.m_is_saved_tick_count = true
    end
    -- @note: do procedural recharge
    if g_exploits.m_should_recharge and g_exploits.m_is_saved_tick_count then
        g_exploits.m_diff = cmd.tick_count - g_exploits.m_recharge_tick_count
        -- @note: simple teleport
        if g_menu.m_double_tap_additives:get_value( 0 ) then cmd.send_packet = false end
    end
    -- @note: when time is out we disable charge
    if g_exploits.m_diff > 14 and g_exploits.m_should_recharge and g_exploits.m_is_saved_tick_count then
        g_exploits.m_should_recharge = false
        g_exploits.m_is_saved_tick_count = false
        g_exploits.m_diff = 0
    end

    g_functional.better_exploits( )
end

client.register_callback( 'create_move', on_create_move )

-- @note: shot fired region
local function on_shot_fired( info )
    g_exploits.m_cheat_fire = true
    g_exploits.m_cheat_fire_time = globalvars.get_current_time( )
end

client.register_callback( 'shot_fired', on_shot_fired )